# Техническая документация проекта: LinkedIn Easy Apply Bot

## 1. Введение

Этот документ описывает техническую архитектуру и внутреннее устройство проекта **LinkedIn Easy Apply Bot**. Основная цель бота — автоматизировать процесс поиска и подачи заявок на вакансии в LinkedIn, используя технологию "Easy Apply".

Бот работает в несколько этапов:
1.  **Обнаружение (Discovery):** Поиск новых вакансий по заданным критериям.
2.  **Обогащение (Enrichment):** Сбор подробной информации о найденных вакансиях.
3.  **Обработка (Processing):** Фильтрация и подача заявок на подходящие вакансии.

Проект использует `playwright` для автоматизации браузера, `sqlite` для хранения данных и гибкую систему конфигурации для настройки параметров поиска и данных для автозаполнения.

## 2. Архитектура и структура директорий

Проект имеет модульную структуру, где каждая директория отвечает за определенную часть функциональности.

```
.
├── actions/                # Основные действия (login, fetch, apply)
│   ├── apply.py            # Логика подачи заявки
│   ├── fetch_jobs.py       # Сбор ссылок и деталей вакансий
│   └── login.py            # Логика входа в LinkedIn
├── apply_form/             # Модули для заполнения полей формы
│   ├── fill_fields.py      # Оркестратор заполнения полей
│   ├── ...                 # Специализированные функции для разных типов полей
├── core/                   # Ядро проекта
│   ├── database.py         # Взаимодействие с базой данных SQLite
│   ├── logger.py           # Настройка логирования
│   ├── selectors.py        # CSS-селекторы для элементов на страницах
│   └── utils.py            # Вспомогательные функции
├── phases/                 # Основные фазы работы бота
│   ├── discovery.py        # Фаза поиска вакансий
│   ├── enrichment.py       # Фаза сбора детальной информации
│   └── processing.py       # Фаза фильтрации и подачи заявок
├── main.py                 # Точка входа в приложение
├── config.py               # Файл конфигурации
├── jobs.db                 # База данных SQLite
└── structure.md            # Этот документ
```

### 2.1. Точки входа

*   **Основная точка входа:** `main.py`. Этот скрипт запускает асинхронную функцию `main()`, которая оркеструет весь процесс работы бота.
*   **Режимы запуска:** Бот может быть запущен в одном из нескольких режимов, которые определяются переменной `BOT_MODE` в `config.py`:
    *   `discovery`: Только поиск и сохранение ссылок на вакансии.
    *   `enrichment`: Поиск, сохранение и обогащение вакансий деталями.
    *   `processing`: Только обработка (подача заявок) уже обогащенных вакансий.
    *   `full_run`: Выполнение всех трех фаз последовательно.
*   **Аргументы командной строки:** Скрипт принимает аргумент `SUBMIT` для переключения из режима "пробного запуска" (dry run) в режим реальной подачи заявок.

## 3. Описание модулей и зависимостей

### 3.1. `main.py`

*   **Назначение:** Главный оркестратор.
*   **Логика:**
    1.  Настраивает логирование (`core/logger.py`).
    2.  Инициализирует базу данных (`core/database.py`).
    3.  Проверяет дневной лимит поданных заявок.
    4.  Запускает `playwright` и создает контекст браузера.
    5.  Выполняет вход в LinkedIn (`actions/login.py`).
    6.  Последовательно запускает фазы (`discovery`, `enrichment`, `processing`) в зависимости от `BOT_MODE`.
    7.  Закрывает контекст браузера.

### 3.2. `config.py`

*   **Назначение:** Централизованное хранение всех настроек.
*   **Содержит:**
    *   Учетные данные LinkedIn.
    *   Параметры поиска вакансий (ключевые слова, география, фильтры).
    *   Регулярные выражения для фильтрации вакансий по названию и описанию.
    *   Данные для автозаполнения форм (телефон, город, опыт работы, ответы на вопросы).
    *   Настройки поведения бота (режим работы, лимиты, задержки).

### 3.3. Директория `core`

*   `database.py`: Модуль для работы с `SQLite`. Определяет схему БД и функции для CRUD-операций с вакансиями и историей запусков.
*   `selectors.py`: Содержит словарь CSS-селекторов, используемых `playwright` для поиска элементов на страницах LinkedIn. Это позволяет легко обновлять селекторы при изменениях в верстке сайта.
*   `logger.py`: Настраивает глобальный логгер.
*   `utils.py`: Содержит вспомогательные функции, например, `wait()` для создания задержек.

### 3.4. Директория `phases`

*   `discovery.py`: Реализует фазу поиска. Вычисляет временной фильтр на основе последнего запуска, вызывает `actions.fetch_jobs.fetch_job_links_user()` и сохраняет результат в БД.
*   `enrichment.py`: Реализует фазу обогащения. Получает "обнаруженные" вакансии из БД, для каждой из них вызывает `actions.fetch_jobs.fetch_job_details()` для сбора полной информации и обновляет запись в БД.
*   `processing.py`: Реализует фазу подачи заявок. Получает "обогащенные" вакансии, фильтрует их по критериям из `config.py`, и для подходящих вызывает `actions.apply.apply_to_job()`.

### 3.5. Директория `actions`

*   `login.py`: Управляет процессом входа. Проверяет наличие активной сессии и, если ее нет, выполняет вход, обрабатывая возможную капчу.
*   `fetch_jobs.py`: Содержит основную логику скрейпинга.
    *   `fetch_job_links_user()`: Выполняет поиск вакансий, обрабатывает пагинацию и собирает первичные данные.
    *   `fetch_job_details()`: Переходит на страницу вакансии и на страницу компании для сбора всех деталей.
*   `apply.py`: Оркестрирует процесс подачи заявки. Нажимает кнопку "Easy Apply" и циклически проходит по страницам формы, вызывая `apply_form.fill_fields` для заполнения полей.

### 3.6. Директория `apply_form`

*   `fill_fields.py`: Главный модуль, который координирует заполнение всех полей формы.
*   Остальные файлы (`fill_text_fields.py`, `upload_docs.py` и т.д.) являются специализированными обработчиками для конкретных типов полей (текстовые, выбор из списка, загрузка файлов, чекбоксы).

## 4. База данных

*   **СУБД:** SQLite.
*   **Файл:** `jobs.db`.

### 4.1. Таблица `vacancies`

*   **Назначение:** Хранение информации о вакансиях.
*   **Структура:**
    *   `id` (INTEGER, PRIMARY KEY): ID вакансии из LinkedIn.
    *   `title` (TEXT): Название вакансии.
    *   `company` (TEXT): Название компании.
    *   `link` (TEXT): Ссылка на вакансию.
    *   `status` (TEXT): Текущий статус (`discovered`, `enriched`, `applied`, `skipped_filter`, `error`, `enrichment_error`).
    *   `created_at` (TIMESTAMP): Время обнаружения.
    *   `description` (TEXT): Полное описание вакансии.
    *   `company_description` (TEXT): Описание компании.
    *   ... и другие поля с деталями о вакансии и компании.

### 4.2. Таблица `run_history`

*   **Назначение:** Хранение временных меток успешных запусков бота.
*   **Структура:**
    *   `id` (INTEGER, PRIMARY KEY AUTOINCREMENT).
    *   `run_timestamp` (TIMESTAMP): Временная метка запуска.

## 5. Бизнес-логика

### 5.1. Основной сценарий (Full Run)

1.  **Запуск:** Пользователь запускает `main.py`.
2.  **Инициализация:** Приложение настраивает окружение, БД и входит в LinkedIn.
3.  **Фаза Discovery:**
    *   Бот определяет, какие вакансии являются "новыми" с момента последнего запуска.
    *   Выполняется поиск на LinkedIn с критериями из `config.py`.
    *   Ссылки на найденные вакансии сохраняются в `vacancies` со статусом `discovered`.
4.  **Фаза Enrichment:**
    *   Бот извлекает из БД все вакансии со статусом `discovered`.
    *   Для каждой вакансии открывается ее страница и страница компании.
    *   Скрейпятся детальные данные (описание, требования и т.д.).
    *   Запись в `vacancies` обновляется, и статус меняется на `enriched`.
5.  **Фаза Processing:**
    *   Бот извлекает из БД все вакансии со статусом `enriched`.
    *   Каждая вакансия фильтруется по регулярным выражениям (`JOB_TITLE`, `JOB_DESCRIPTION`) и языку из `config.py`. Неподходящие получают статус `skipped_filter`.
    *   Для подходящих вакансий запускается процесс подачи заявки.
    *   Бот циклически заполняет страницы формы, используя данные из `config.py`.
    *   Если запуск не в режиме `SUBMIT`, бот останавливается перед последним шагом.
    *   В режиме `SUBMIT` заявка отправляется, и статус вакансии меняется на `applied`.

## 6. Интеграции и внешние зависимости

*   **Основная интеграция:** Веб-сайт `linkedin.com`. Взаимодействие происходит через HTTP-запросы, управляемые библиотекой `playwright`.
*   **Ключевые библиотеки Python:**
    *   `playwright`: Для автоматизации браузера.
    *   `langdetect`: Для определения языка описания вакансии.

## 7. Инфраструктура и конфигурация

*   **Запуск:** Проект запускается как простой Python-скрипт.
*   **Конфигурация:** Вся конфигурация находится в `config.py`. Секреты (пароль от LinkedIn) хранятся в этом же файле в виде текста.
*   **Зависимости:** Управляются через `pyproject.toml` и `uv.lock`.

## 8. Рекомендации для тестирования

### 8.1. Юнит-тесты

*   **`core/database.py`:** Функции `save_discovered_jobs`, `count_todays_applications` и другие могут быть протестированы с использованием in-memory SQLite базы данных.
*   **`phases/processing.py`:** Функцию `_is_job_suitable` следует покрыть тестами с различными вариантами данных о вакансиях и паттернов, чтобы убедиться в корректности фильтрации.
*   **`apply_form`:** Каждый модуль в этой директории (например, `fill_text_fields`) должен быть протестирован отдельно. Для этого нужно мокировать объект `page` из `playwright` и проверять, что вызываются правильные методы (`.type()`, `.click()` и т.д.) с правильными селекторами и данными.

### 8.2. Интеграционные тесты

*   **Взаимодействие фаз:** Следует написать тесты, проверяющие корректность перехода вакансии по статусам: `discovered` -> `enriched` -> `applied`/`skipped_filter`. Это можно сделать, запуская фазы последовательно на реальной, но изолированной БД.
*   **`actions` и `apply_form`:** Можно протестировать связку `actions.apply` и `apply_form.fill_fields`, создав фейковую HTML-страницу с формой заявки и проверив, что `playwright` корректно ее заполняет.

### 8.3. End-to-End тесты

*   Полный E2E-тест будет включать запуск всего процесса (`full_run`) на тестовом аккаунте LinkedIn. Это дорого и хрупко из-за возможных изменений на сайте и капчи. Основной фокус следует сделать на юнит- и интеграционных тестах.

### 8.4. Что мокировать

*   **`playwright.async_api.Page`:** Почти во всех тестах, кроме E2E, объект `page` и его методы должны быть замокированы.
*   **`core.database`:** При тестировании логики фаз можно мокировать функции базы данных, чтобы изолировать логику от состояния БД.
*   **Внешние HTTP-запросы:** Если бы были прямые API-вызовы, их следовало бы мокировать. В данном случае мокируется `playwright`.

"""
LLMDelegate: Abstraction layer for LLM-based form field decisions.

Based on creative phase design document.
"""

import logging
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any, Literal

from pydantic import BaseModel, Field, field_validator, model_validator

from modal_flow.profile_schema import CandidateProfile


class SuggestedStrategy(BaseModel):
    """Suggested strategy structure for new rules."""
    kind: str
    params: Optional[Dict[str, Any]] = None


class LLMDecision(BaseModel):
    """
    Structured response from LLM for field decision.
    
    Based on technical specification section 4.4.
    """
    decision: Literal["select", "text", "number", "check", "skip"]
    value: Any
    confidence: float = Field(..., ge=0, le=1)
    suggest_rule: Optional[Dict[str, Any]] = None
    # NOTE: suggest_rule is deprecated. Rule generation is now handled separately
    # via generate_rule() method. This field is kept for backward compatibility.
    
    class Config:
        # Allow extra fields for flexibility
        extra = "allow"


class StrategyDefinition(BaseModel):
    """
    Strategy definition for rule execution.
    
    Represents how a field should be filled based on the rule.
    """
    kind: str = Field(..., description="Strategy kind: literal, profile_key, numeric_from_profile, one_of_options, one_of_options_from_profile, salary_by_currency")
    params: Dict[str, Any] = Field(default_factory=dict, description="Strategy-specific parameters")
    
    @model_validator(mode='after')
    def validate_params(self):
        """Validate that params contain required fields for each strategy kind."""
        kind = self.kind
        params = self.params or {}
        
        # Define required params for each strategy kind
        required_params = {
            "literal": ["value"],
            "profile_key": ["key"],
            "numeric_from_profile": ["key"],
            "one_of_options": [],  # Either "preferred" or "synonyms" should be present
            "one_of_options_from_profile": ["key"],  # "synonyms" is optional but recommended
            "salary_by_currency": ["base_key_template", "default_currency"],
        }
        
        # Check for literal strategy
        if kind == "literal":
            if "value" not in params:
                raise ValueError(f"Strategy 'literal' requires 'value' in params, got: {params}")
        
        # Check for profile_key strategy
        elif kind == "profile_key":
            if "key" not in params or not params.get("key"):
                raise ValueError(f"Strategy 'profile_key' requires 'key' in params, got: {params}")
        
        # Check for numeric_from_profile strategy
        elif kind == "numeric_from_profile":
            if "key" not in params or not params.get("key"):
                raise ValueError(f"Strategy 'numeric_from_profile' requires 'key' in params, got: {params}")
        
        # Check for one_of_options strategy
        elif kind == "one_of_options":
            if "preferred" not in params and "synonyms" not in params:
                raise ValueError(f"Strategy 'one_of_options' requires either 'preferred' or 'synonyms' in params, got: {params}")
        
        # Check for one_of_options_from_profile strategy
        elif kind == "one_of_options_from_profile":
            if "key" not in params or not params.get("key"):
                raise ValueError(f"Strategy 'one_of_options_from_profile' requires 'key' in params, got: {params}")
            # synonyms is optional but recommended
            if "synonyms" not in params or not params.get("synonyms"):
                # This is a warning, not an error - we can try to use the value directly
                pass
        
        # Check for salary_by_currency strategy
        elif kind == "salary_by_currency":
            if "base_key_template" not in params or "default_currency" not in params:
                raise ValueError(f"Strategy 'salary_by_currency' requires 'base_key_template' and 'default_currency' in params, got: {params}")
        
        return self


class RuleSuggestion(BaseModel):
    """
    Structured response for rule generation.
    
    Represents a rule suggestion generated by LLM for automatic form field filling.
    """
    q_pattern: str = Field(..., description="Regex pattern to match the field question")
    strategy: StrategyDefinition = Field(..., description="Strategy definition with kind and params")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Confidence score for this rule")


class BaseLLMDelegate(ABC):
    """
    Abstract base class for LLM delegates.
    
    Provides a common interface for different LLM providers.
    """
    
    @abstractmethod
    async def decide(
        self,
        field_info: Dict[str, Any],
        profile: CandidateProfile,
        job_context: Optional[Dict[str, Any]] = None
    ) -> LLMDecision:
        """
        Ask the LLM to make a decision for a given field.
        
        Args:
            field_info: Dictionary containing field information:
                - question: str
                - field_type: str (radio, checkbox, select, text, number)
                - options: Optional[List[str]]
                - required: bool
            profile: Candidate profile
            job_context: Optional job context (job title, description, etc.)
            
        Returns:
            LLMDecision with decision, value, confidence, and optional suggest_rule
        """
        pass
    
    @abstractmethod
    async def generate_rule(
        self,
        field_info: Dict[str, Any],
        selected_value: Any,
        profile: CandidateProfile,
        job_context: Optional[Dict[str, Any]] = None
    ) -> Optional["RuleSuggestion"]:
        """
        Generate a rule for a field based on the decision made.
        
        This method is called AFTER a decision has been made to generate
        a reusable rule for future similar fields.
        
        Args:
            field_info: Dictionary containing field information:
                - question: str
                - field_type: str (radio, checkbox, select, text, number)
                - options: Optional[List[str]]
                - required: bool
            selected_value: The value that was selected for this field
            profile: Candidate profile
            job_context: Optional job context (job title, description, etc.)
            
        Returns:
            RuleSuggestion if rule generation succeeds, None otherwise
        """
        pass

